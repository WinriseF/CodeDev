### 第一阶段：GPU 进程瘦身 (目标：250MB -> 100MB 左右)

这是目前占用最大的部分，主要由 CSS 特效和 Monaco Editor 引起。

#### 1. 移除/降级高开销 CSS 特效
*   **优化方案**：
    *   移除 `SpotlightApp.tsx` 和 `Sidebar.tsx` 中的无限循环动画（如 `animate-gradient-flow` 和 `animate-gradient-dot`）。
    *   移除或大幅减少 `backdrop-blur`（背景模糊）的使用，改用半透明纯色背景。
    *   移除 `PromptDetailTooltip` 中复杂的 `conic-gradient` 旋转动画。
*   **技术原理**：
    *   **模糊成本**：CSS 的 `backdrop-blur` 会强制 GPU 创建额外的纹理缓冲区（Texture Buffer）来通过卷积算法计算模糊，这非常消耗显存。
    *   **动画成本**：无限循环的 CSS 动画会导致 GPU 无法进入休眠状态，必须持续以 60FPS 重绘合成层（Composite Layer），导致显存和电量双重消耗。
*   **造成的影响**：
    *   **视觉**：界面会变得稍微“朴素”一些，不再有那种毛玻璃的高级感和流动的光效。
    *   **性能**：窗口拖动、缩放会变得非常丝滑，GPU 占用率会直线下降。

#### 2. 优化 Monaco Editor 生命周期
*   **优化方案**：
    *   在 `DiffViewer.tsx` 和 `ContextPreview.tsx` 中，确保组件在隐藏（例如 Tab 切换不可见）时，彻底销毁 Editor 实例，而不是仅仅 `display: none`。
    *   配置 Editor 的 `automaticLayout: false`，改为手动监听 ResizeObserver。
*   **技术原理**：
    *   Monaco Editor 本质上是基于 Canvas 和大量 DOM 的。每个实例都会创建独立的 WebGL 上下文或复杂的层级。隐藏而不销毁依然占用显存。
*   **造成的影响**：
    *   **体验**：切换 Tab（如从“预览”切回“仪表盘”）时，下次切回来可能有一瞬间的重新加载白屏（<100ms），不再是无缝切换。

---

### 第二阶段：Rust 主进程优化 (目标：50MB -> 20MB 左右)

50MB 对于主进程来说偏大，主要问题在于“贪婪加载”。

#### 1. Sysinfo 按需加载
*   **优化方案**：
    *   修改 `main.rs` 和 `ClockPopover.tsx` 的交互逻辑。不再在 App 启动时初始化全局的 `System` 结构体并 `refresh_all()`。
    *   创建一个新的轻量级命令，仅在用户点击时钟弹窗时，才实例化 System 获取数据，用完即丢弃（或仅刷新特定组件）。
*   **技术原理**：
    *   `sysinfo::System` 结构体维护着操作系统所有进程的列表和句柄。`refresh_all()` 会将系统所有进程信息加载到 Rust 堆内存中。对于一个只需要看 CPU/内存占用的小功能，这是杀鸡用牛刀。
*   **造成的影响**：
    *   **功能**：无影响。
    *   **体验**：点击时钟弹窗时，第一次显示数据可能会有微小的延迟（毫秒级），之前是实时缓存的。

#### 2. Git Diff 零拷贝优化
*   **优化方案**：
    *   修改 `git.rs`。在读取文件内容进行 Diff 时，设定一个阈值（例如 100KB）。
    *   对于大文件，不读取完整内容到 String，直接返回 `[Large File Omitted]` 标记。
    *   优化 `scan_for_secrets`，避免在大字符串在 JS 和 Rust 之间来回传递时的深拷贝。
*   **技术原理**：
    *   Rust 的 `String` 是存储在堆上的。如果 Git 历史中有大文件（比如误上传的 DLL 或大图），直接 `read_to_string` 会导致内存瞬间飙升。
*   **造成的影响**：
    *   **功能**：在“Patch Weaver”界面，如果文件过大，用户将无法看到具体的 Diff 内容，只能看到提示。这是合理的保护机制。

---

### 第三阶段：渲染进程 (JS) 优化 (目标：削减 30%~50%)

#### 1. 提示词库 (Prompt Store) 索引化
*   **优化方案**：
    *   修改 `usePromptStore.ts`。`initStore` **不再**将所有 `json` 文件的完整内容（content 字段）加载到内存中的 `repoPrompts` 数组。
    *   仅加载 `id`, `title`, `group`, `tags` 等元数据用于列表显示和搜索。
    *   只有当用户点击某个 Prompt 卡片准备编辑或复制时，再异步从磁盘读取 `content`。
*   **技术原理**：
    *   **V8 堆内存限制**：JS 对象常驻内存。如果有 5000 条 Prompt，每条都有大段的 `content` 字符串，这将占用巨大的 V8 老生代（Old Generation）内存空间。
*   **造成的影响**：
    *   **搜索**：**这是最大的功能变更点**。如果仅加载元数据，用户将**无法**通过搜索“提示词的具体内容”来找到指令，只能通过标题、标签或描述搜索。
    *   *补救措施*：如果必须搜索内容，我们可以保持现状，但对内容进行截断存储，或者接受这部分内存开销。**请确认这一点是否可以接受？**

#### 2. Context 拼接优化
*   **优化方案**：
    *   在 `ContextPreview.tsx` 中，不要在 React State 中存储生成的巨型字符串。
    *   利用 Monaco Editor 的 `setValue` 直接设置，或者使用 Blob URL。
*   **技术原理**：
    *   React 的 `useState` 会导致字符串保留引用。当字符串极大（如几兆的代码上下文）时，GC 回收可能会滞后。

---

### 总结与决策

在开始写代码之前，我需要你确认以下几点关键决策：

1.  **视觉降级**：你是否接受移除背景模糊（毛玻璃）效果和无限循环光效动画？（这对降 GPU 内存最有效）。
2.  **搜索体验**：你是否接受 Prompt 库在未打开详情前，**搜索范围仅限于标题和描述**，而不包含具体的 Prompt 内容？（这对降 JS 内存最有效）。
3.  **编辑器体验**：你是否接受切换 Tab 时 Editor 重新初始化的轻微闪烁？

如果你同意以上三点（或者有保留意见），请告诉我，我将生成对应的代码。